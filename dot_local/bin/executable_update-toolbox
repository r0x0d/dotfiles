#!/usr/bin/env python3
import argparse
import sys
import subprocess
import threading
import time
import itertools


class Colors:
    """ANSI color codes."""
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    RESET = '\033[0m'


class Spinner:
    """A simple spinner for showing progress."""
    
    def __init__(self, message="Processing"):
        self.message = message
        self.spinner = itertools.cycle(['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'])
        self.running = False
        self.thread = None
    
    def _spin(self):
        """Internal spinning method."""
        while self.running:
            sys.stdout.write(f'\r{Colors.CYAN}{next(self.spinner)}{Colors.RESET} {self.message}...')
            sys.stdout.flush()
            time.sleep(0.1)
    
    def start(self):
        """Start the spinner."""
        self.running = True
        self.thread = threading.Thread(target=self._spin)
        self.thread.daemon = True
        self.thread.start()
    
    def stop(self, success=True, message=None):
        """Stop the spinner and show result."""
        self.running = False
        if self.thread:
            self.thread.join()
        
        # Clear the line
        sys.stdout.write('\r' + ' ' * (len(self.message) + 20) + '\r')
        
        if message:
            if success:
                sys.stdout.write(f'{Colors.GREEN}✓{Colors.RESET} {message}\n')
            else:
                sys.stdout.write(f'{Colors.RED}✗{Colors.RESET} {message}\n')
        
        sys.stdout.flush()


def print_header(text):
    """Print a colored header."""
    print(f'\n{Colors.BOLD}{Colors.BLUE}=== {text} ==={Colors.RESET}\n')


def print_success(text):
    """Print success message."""
    print(f'{Colors.GREEN}✓{Colors.RESET} {text}')


def print_warning(text):
    """Print warning message."""
    print(f'{Colors.YELLOW}⚠{Colors.RESET} {text}')


def print_error(text):
    """Print error message."""
    print(f'{Colors.RED}✗{Colors.RESET} {text}')


def print_info(text):
    """Print info message."""
    print(f'{Colors.CYAN}ℹ{Colors.RESET} {text}')


def run_command(cmd, check=False):
    """Run a shell command and return the result."""
    try:
        result = subprocess.run(
            cmd,
            shell=True,
            capture_output=True,
            text=True,
            check=check
        )
        return result
    except subprocess.CalledProcessError as e:
        return e


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Toolbox Container Update Script"
    )
    parser.add_argument(
        "--only-toolbox",
        action="store_true",
        help="Only recreate toolbox containers, skip pulling images"
    )
    parser.add_argument(
        "--only-podman",
        action="store_true",
        help="Only pull images, skip recreating toolbox containers"
    )
    args = parser.parse_args()
    
    # Validate that both flags aren't set
    if args.only_toolbox and args.only_podman:
        parser.error("Cannot specify both --only-toolbox and --only-podman")
    
    return args


def find_toolbox_images():
    """Find all quay.io/toolbox-dev images."""
    spinner = Spinner("Finding toolbox images")
    spinner.start()
    
    result = run_command('podman images --format "{{.Repository}}:{{.Tag}}" | grep "^quay.io/toolbox-dev"')
    
    if result.returncode != 0 or not result.stdout.strip():
        spinner.stop(False, "No toolbox images found starting with quay.io/toolbox-dev")
        return []
    
    images = result.stdout.strip().split('\n')
    spinner.stop(True, f"Found {len(images)} toolbox image(s)")
    
    for image in images:
        print(f"  {Colors.CYAN}•{Colors.RESET} {image}")
    print()
    
    return images


def pull_images(images):
    """Pull latest versions of each image."""
    for image in images:
        spinner = Spinner(f"Pulling {image}")
        spinner.start()
        
        result = run_command(f'podman pull "{image}"')
        
        if result.returncode != 0:
            spinner.stop(False, f"Failed to pull {image}")
            if result.stderr:
                print_error(f"  Error: {result.stderr.strip()}")
        else:
            spinner.stop(True, f"Pulled {image}")
    
    print()


def get_all_toolbox_containers():
    """Get all toolbox containers using toolbox CLI."""
    spinner = Spinner("Listing toolbox containers")
    spinner.start()
    
    result = run_command("toolbox list --containers 2>/dev/null | awk 'NR>1 {print $2}'")
    
    if result.returncode != 0 or not result.stdout.strip():
        spinner.stop(False, "No toolbox containers found")
        return []
    
    containers = result.stdout.strip().split('\n')
    spinner.stop(True, f"Found {len(containers)} toolbox container(s)")
    
    return containers


def recreate_container(container_name):
    """Recreate a single container."""
    print(f'\n{Colors.BOLD}Container:{Colors.RESET} {container_name}')
    
    # Get the image used by this container
    spinner = Spinner(f"Inspecting {container_name}")
    spinner.start()
    
    result = run_command(f"podman inspect {container_name} --format '{{{{.ImageName}}}}'")
    
    if result.returncode != 0 or not result.stdout.strip():
        spinner.stop(False, f"Could not determine image for {container_name}")
        if result.stderr:
            print_error(f"  Error: {result.stderr.strip()}")
        return
    
    image_name = result.stdout.strip()
    
    if not image_name.startswith("quay.io/toolbox-dev"):
        spinner.stop(False, f"Skipping {container_name} (not a toolbox-dev image)")
        return
    
    spinner.stop(True, f"Using image: {image_name}")
    
    # Remove old container
    spinner = Spinner(f"Removing old container")
    spinner.start()
    
    result = run_command(f"toolbox rm -f {container_name}")
    
    if result.returncode != 0:
        spinner.stop(False, "Failed to remove container")
        if result.stderr:
            print_error(f"  Error: {result.stderr.strip()}")
        return
    
    spinner.stop(True, "Removed old container")
    
    # Create new container
    spinner = Spinner(f"Creating new container")
    spinner.start()
    
    result = run_command(f'toolbox create -c "{container_name}" -i "{image_name}"')
    
    if result.returncode != 0:
        spinner.stop(False, "Failed to create container")
        if result.stderr:
            print_error(f"  Error: {result.stderr.strip()}")
        return
    
    spinner.stop(True, f"Container {container_name} recreated successfully")


def main():
    """Main function."""
    args = parse_arguments()
    
    print_header("Toolbox Container Update Script")
    
    # Determine what operations to perform
    should_pull = not args.only_toolbox
    should_recreate = not args.only_podman
    
    # Pull images
    if should_pull:
        print_header("Updating Images")
        images = find_toolbox_images()
        if not images:
            if args.only_podman:
                # If only pulling and no images found, exit
                sys.exit(0)
            # Otherwise continue to recreate containers
        else:
            pull_images(images)
    else:
        print_info("Skipping image pull (--only-toolbox flag set)\n")
    
    # Recreate containers
    if should_recreate:
        print_header("Recreating Containers")
        
        containers = get_all_toolbox_containers()
        if not containers:
            sys.exit(0)
        
        for container in containers:
            print(f"  {Colors.CYAN}•{Colors.RESET} {container}")
        
        for container in containers:
            recreate_container(container)
    else:
        print_info("Skipping container recreation (--only-podman flag set)\n")
    
    print_header("Update Complete")
    print_success("All operations completed successfully!\n")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f'\n\n{Colors.YELLOW}Operation cancelled by user{Colors.RESET}')
        sys.exit(1)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        sys.exit(1)
